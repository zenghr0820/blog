---
title: "SpringCloud Gateway"
date: "2021-07-29 18:00"
permalink: "2021-07-29-spring-cloud-gateway"

---

# SpringCloud Gateway教程

:::tip

本章节记录一下 SpringCloud 下的微服务网关 **Gateway** 的入门教程，版本环境如下👇

***SpringBoot：2.5.3***

***SpringCloud：`2020.0.3`***

***SpringCloudAlibaba：2021.1***

***nacos：14.1***

***Gateway：`3.0.3`***

:::

## Gateway 简介

Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。

网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。而 springcloud gateway 作为 SpringCloud 官方推出的第二代网关框架，取代了 Zuul 网关

> 声明：**Spring Cloud Gateway 底层使用了高性能的通信框架Netty**
>
> 官方网址：[https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/)

## 核心概念

- **Route（路由）：** 这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配
- **Predicate（断言）：** Java8 中的断言函数。Spring Cloud Gateway 中的断言函数输入类型是 Spring5.0 框 架中的 ServerWebExchange。Spring Cloud Gateway 中的断言函数允许开发者去定义匹配 来自于 http request 中的任何信息，比如请求头和参数等
- **Filter（过滤器）：** 一个标准的 Spring webFilter。Spring cloud gateway 中的 filter 分为两种类型的 Filter，分别是 **`Gateway Filter`** 和 **`Global Filter`**。过滤器 Filter 将会对请求和响应进行修改 处理

**工作原理如下图👇**

![21UTs0](https://media.zenghr.cn/blog/img/20210729/21UTs0.png)

客户端向 Spring Cloud Gateway 发出请求。然后在 **Gateway Handler Mapping** 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler

Handler 再将请求交给一个过滤器链，请求到达目标服务之前，会执行所有过滤器的 **pre** 方法。请求到达目标服务处理之后再依次执行所有过滤器的 **post** 方法

> 总之就是：**满足某些断言(predicates)就路由到指定的地址(uri)，使用指定的过滤器(filter)**

## 搭建 Gateway 环境

要使用 SpringCloud Gateway 需要导入相应的依赖，之后需要设置 **Gateway 的路由配置**

我使用了**`spring-boot 2.5.3`** 作为 parent 依赖

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.5.3</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
```

在 dependencyManagement 中，**我们需要指定 SringCloud 的版本**，以便保证我们能够引入我们想要的 SpringCloud Gateway版本，所以需要用到 **dependencyManagement**

```xml
<properties>
    <spring-cloud.version>2020.0.3</spring-cloud.version>
</properties>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

最后导入我们的 Gateway 依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

> 此外，请检查一下你的依赖中是否含有 **spring-boot-starter-web**，如果有，**请干掉它**。因为我们的SpringCloud Gateway是一个**netty+webflux** 实现的web服务器，和 Springboot Web 本身就是冲突的

## 基础 URI 路由配置方式

如果请求的目标地址，是单个的URI资源路径，配置文件示例如下：

```yaml
server:
  port: 88
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: url-proxy-1
         uri: https://blog.zenghr.cn
         predicates:
           - Path=/blog
```

参数说明：

- **id：** 我们自定义的路由 ID，保持唯一
- **uri：** 目标服务地址
- **predicates：** 路由条件，Predicate 接受一个输入参数，返回一个布尔值结果

上面这段配置的意思是，配置了一个 id 为 **url-proxy-1** 的URI代理规则，路由的规则为：

当访问地址 **`http://localhost:88/blog/1.html`** 时，会路由到上游地址 **`https://blog.zenghr.cn/blog/1.html`**

## 基于代码的路由配置方式

转发功能代码也可以通过代码的方式来实现，我们可以自定义 **`RouteLocator`** Bean 实现自定义制转发规则

```java
@Configuration
public class GatewayConfiguration {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("url-proxy-1",
                        p -> p.predicate(e -> e.getRequest().getURI().getPath().startsWith("/blog"))
                                .filters(f -> f.rewritePath("/blog/(?<remaining>.*)", "/${remaining}"))
                                .uri("https://blog.zenghr.cn"))
                .route("url-proxy-2", p -> p.path("/blog2").uri("https://blog.zenghr.cn"))
                .build();
    }
}
```

我们注释掉 xml 配置文件中的 Gateway 路由设置，重启服务， 当访问地址 **`http://localhost:88/blog/1.html`** 时，会路由到上游地址 **`https://blog.zenghr.cn/1.html`** , 能够访问说明我们的代码配置成功

**参数说明**

通过 **RouteLocatorBuilder** 的routes，可以逐一建立路由，每调用route一次可建立一条路由规则

p 的代表是 PredicateSpec，可以透过它的 **predicate** 来进行断言，要实现的接口就是Java 8的 **Predicate**，通过 exchange 取得了路径，然后判断它是不是以 /blog 开头，对于简单的情况，也可以通过 **path** 等来进行断言

**filters** 是用来设置过滤器，**rewritePath** 方法会使用内建的过滤器重写路径



## 注册中心相结合的路由配置方式

在 uri 的 schema 协议部分为自定义的 **lb:类型**，表示从微服务注册中心（如 Nacos）订阅服务，并且进行服务的路由

> 在我的项目中，使用的是 **gateway + nacos** 的方式来实现的

导入 nacos 的服务注册依赖，需要把 gateway 服务注册到 nacos，才能发现其他服务

```xml
<!-- nacos 服务发现 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<!-- nacos 配置中心 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

如果需要使用 nacos 作为配置中心，也可以导入相应的依赖

我们的配置文件内容需要如下设置👇

```yaml
spring:
  application:
    name: api-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    gateway:
      discovery:
        locator:
          enabled: true # 开启服务发现功能，默认为 false
      routes:
        - id: member_route
          uri: lb://mall-member
          predicates:
            - Path=/api/member/**
          filters:
            - RewritePath=/api/member/(?<segment>.*),/$\{segment}
```

**参数说明**

- **locator.enabled：** 开启服务发现，需要开启该配置
- **lb:** 代表 负载均衡

::: warning

由于 **SpringCloud 2020** 弃用了 Ribbon，因此 Alibaba 在 **`2021 版本 nacos`** 中删除了 Ribbo n的 jar 包，因此无法通过**lb路由到指定微服务，出现了503情况**

所以只需要引入 **springcloud loadbalancer** 包即可

:::

```xml
<!--客户端负载均衡loadbalancer-->
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

## Gateway 匹配规则

Spring Cloud Gateway 是通过 Spring WebFlux 的 HandlerMapping 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用

![U3Me4V](https://media.zenghr.cn/blog/img/20210729/U3Me4V.png)

接下来我们介绍 Spring Cloud GateWay 内置几种 Predicate 的使用

### 通过请求参数匹配

Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式

```yaml
server:
  port: 88
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: url-proxy-1
         uri: https://blog.zenghr.cn
         predicates:
           - Query=url,blog
```

这样配置，只要请求中包含 url 属性的参数，并且参数值是 blog 即可匹配路由

### 通过 Cookie 匹配

Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行

```yaml
server:
  port: 88
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: url-proxy-1
         uri: https://blog.zenghr.cn
         order: 0
         predicates:
           - Cookie=sessionId, test
```

### 通过 Header 属性匹配

Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行

```yaml
server:
  port: 88
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: url-proxy-1
         uri: https://blog.zenghr.cn
         order: 0
         predicates:
           - Header=X-Request-Id, \d+
```

### 通过请求方式匹配

可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由

```yaml
server:
  port: 88
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: url-proxy-1
         uri: https://blog.zenghr.cn
         order: 0
         predicates:
           - Method=GET
```

> 这里我们就只列出一些常用的匹配方式，如果需要查询其他匹配方式，可以查看 [SpringCloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories) 的官方文档

## Gateway 高级功能

### 实现熔断降级<Badge text="TODO"/>



### 分布式限流<Badge text="TODO"/>

