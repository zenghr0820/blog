(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{393:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"java-集合框架体系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-集合框架体系"}},[t._v("#")]),t._v(" Java 集合框架体系")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("本文用于整合 集合框架的知识体系，如有不正确的地方请指出，感谢。")]),t._v(" "),a("p",[a("em",[t._v("JDK Version：1.8.0.212")])])]),t._v(" "),a("h2",{attrs:{id:"数据结构概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构概述"}},[t._v("#")]),t._v(" 数据结构概述")]),t._v(" "),a("p",[t._v("数据结构就是数据在计算机中存储的方式，不同的数据结构，底层采用不同的存储算法，在执行具体的操作时，不同的算法会有不同的效率，有的查询效率慢，有的删除添加效率快等")]),t._v(" "),a("h3",{attrs:{id:"常见的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的数据结构"}},[t._v("#")]),t._v(" 常见的数据结构")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("数组(Array)")])]),t._v(" "),a("li",[a("strong",[t._v("链表(Linked)")])]),t._v(" "),a("li",[a("strong",[t._v("哈希表(Hash)")])]),t._v(" "),a("li",[a("strong",[t._v("栈(Stack)")])]),t._v(" "),a("li",[a("strong",[t._v("队列(Queue)")])]),t._v(" "),a("li",[a("strong",[t._v("树(Tree)")])]),t._v(" "),a("li",[a("strong",[t._v("图(Graph)")])]),t._v(" "),a("li",[a("strong",[t._v("堆(Heap)")])])]),t._v(" "),a("p",[t._v("在日常的开发中，往往根据业务的需要，选择不同的数据结构，选择合适的集合类")]),t._v(" "),a("p",[t._v("这么多数据结构，我们又可以根据其数据结构特性("),a("code",[t._v("是否连成一条线")]),t._v(")，分为 "),a("strong",[t._v("线性数据结构")]),t._v(" 和 "),a("strong",[t._v("非线性数据结构")])]),t._v(" "),a("h3",{attrs:{id:"线性数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线性数据结构"}},[t._v("#")]),t._v(" 线性数据结构")]),t._v(" "),a("h4",{attrs:{id:"数组-array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组-array"}},[t._v("#")]),t._v(" 数组(Array)")]),t._v(" "),a("p",[t._v("把具有相同类型的数据有序地组织在一起，称为数组。数组使用 "),a("strong",[t._v("索引/下标")]),t._v(" 来表示元素的存储位置。")]),t._v(" "),a("p",[a("strong",[t._v("性能分析")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("添加操作：")]),t._v(" "),a("p",[t._v("如果是添加到数组尾部，只需要操作一次")]),t._v(" "),a("p",[t._v("如果添加到其他位置，则需要把后面的元素整体后移")])]),t._v(" "),a("li",[a("p",[t._v("删除操作：")]),t._v(" "),a("p",[t._v("如果是删除尾部元素，只需要操作一次")]),t._v(" "),a("p",[t._v("如果是删除其他位置元素，则需要把元素整体后移")])]),t._v(" "),a("li",[a("p",[t._v("修改操作：")]),t._v(" "),a("p",[t._v("给定索引，操作一次")]),t._v(" "),a("p",[t._v("根据内容，操作N次")])]),t._v(" "),a("li",[a("p",[t._v("查询操作：")]),t._v(" "),a("p",[t._v("给定索引，操作一次")]),t._v(" "),a("p",[t._v("根据内容，操作N次")])])]),t._v(" "),a("p",[t._v("总结：基于数组(Array)的数据结构做查询修改是非常快的，添加和删除就比较慢")]),t._v(" "),a("h4",{attrs:{id:"链表-linked"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表-linked"}},[t._v("#")]),t._v(" 链表(Linked)")]),t._v(" "),a("p",[t._v("每个元素在内存中的位置不是有序的，而是通过在每个元素中记录下一个元素的位置链接在一起，称为链表。")]),t._v(" "),a("p",[t._v("链表又分为 单向链表 和 双向链表")]),t._v(" "),a("ul",[a("li",[t._v("单向链表：元素中只记录了下一个元素的位置，所以只能单向遍历")]),t._v(" "),a("li",[t._v("双向链表：元素中记录了 上一个元素和下一个元素的位置，实现双向遍历")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/LI9Wp8kMRf6s.png?imageslim",alt:"mark"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/q9bh5g5vWet3.png?imageslim",alt:"mark"}})]),t._v(" "),a("p",[a("strong",[t._v("性能分析")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("添加操作：")]),t._v(" "),a("p",[t._v("添加位置在头部或尾部，操作一次")]),t._v(" "),a("p",[t._v("添加位置在其他位置，需要覆盖原有元素指向的位置，指向新的元素位置，新的元素则需要指向原有元素指向的位置")])]),t._v(" "),a("li",[a("p",[t._v("删除操作：")]),t._v(" "),a("p",[t._v("如果删除的元素是头部或尾部，操作一次")]),t._v(" "),a("p",[t._v("如果是中间元素，需要找到元素，删除操作一次")])]),t._v(" "),a("li",[a("p",[t._v("修改操作：")]),t._v(" "),a("p",[t._v("平均 (N + 1) / 2")])]),t._v(" "),a("li",[a("p",[t._v("查询操作：")]),t._v(" "),a("p",[t._v("平均 (N + 1) / 2")])])]),t._v(" "),a("p",[t._v("总结：链表(Linked) 数据结构对于 添加删除操作较快，查询修改比较慢")]),t._v(" "),a("h4",{attrs:{id:"队列-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列-queue"}},[t._v("#")]),t._v(" 队列(Queue)")]),t._v(" "),a("p",[t._v("队列是一种特殊的线性表，它只允许在头部进行删除操作，尾部进行添加操作，是一种受限制的线性表。")]),t._v(" "),a("p",[t._v("队列又分为 单向队列 和 双向队列:")]),t._v(" "),a("ul",[a("li",[t._v("单向队列(Queue)：先进先出，只能在队尾插入，从队列头部删除")]),t._v(" "),a("li",[t._v("双向队列(Deque)：两端都可以进行添加删除数据，不能操作中间的数据")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/lSzKkkebCV20.png?imageslim",alt:"单向队列"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/FtkpcnNHuvqe.png?imageslim",alt:"双向队列"}})]),t._v(" "),a("p",[t._v("总结：擅长操作头部和尾部")]),t._v(" "),a("h4",{attrs:{id:"栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[t._v("#")]),t._v(" 栈(stack)")]),t._v(" "),a("p",[t._v("栈（stack）又名堆栈，它是一种运算受限的线性表，后进先出(LIFO)。")]),t._v(" "),a("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://media.zenghr.cn/blog/img/20210426/AAjnrOjbiFIU.png?imageslim",alt:"栈结构"}}),t._v(" "),a("p",[t._v("栈结构仅允许在表的一端进行插入和删除运算，这一端被称为 "),a("strong",[t._v("栈顶")]),t._v("，相对地，把另一端称为 "),a("strong",[t._v("栈底")]),t._v("。\n向一个栈中插入新元素又称作 "),a("strong",[t._v("入栈")]),t._v("，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素。从一\n个栈中删除元素又称作 "),a("strong",[t._v("出栈")])]),t._v(" "),a("h2",{attrs:{id:"集合框架体系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合框架体系"}},[t._v("#")]),t._v(" 集合框架体系")]),t._v(" "),a("p",[t._v("集合是Java中提供的一种容器，可以用来存储多个数据，根据不同的存储方式形成的体系结构，就叫做集合框架体系。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/HGAR6bEbSSch.png?imageslim",alt:"集合继承关系"}})]),t._v(" "),a("p",[t._v("每一种容器类底层拥有不同的底层算法(数据结构)。")]),t._v(" "),a("h2",{attrs:{id:"iterable-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iterable-接口"}},[t._v("#")]),t._v(" Iterable 接口")]),t._v(" "),a("p",[t._v("从上图可以看出 "),a("strong",[t._v("Iterable")]),t._v(" 接口是所有集合的超类， 实现此接口允许对象成为 for-each 循环的目标，它是 Java 中的一种 "),a("code",[t._v("语法糖")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("其他遍历方式")])]),t._v(" "),a("p",[a("strong",[t._v("Iterable")]),t._v(" 接口有一个方法，就是")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iterator")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("该方法能创建一个轻量级的迭代器，用于安全的遍历元素，移除元素，如果在for-each中删除集合中的元素，是不安全的，会抛出 "),a("code",[t._v("ConcurrentModificationException")]),t._v(" 异常，所以尽量使用迭代器的方式进行遍历，删除元素")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iterator")]),t._v(" it "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" coll"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" it"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasNext")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("集合容器主要包括 Collection 和 Map 两种，Collection 存储对象的集合，而 Map 存储 键值对 (key - value)")])]),t._v(" "),a("h2",{attrs:{id:"collection-顶层接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collection-顶层接口"}},[t._v("#")]),t._v(" Collection 顶层接口")]),t._v(" "),a("p",[t._v("Collection 是顶层接口，它主要用于定义集合的约定")]),t._v(" "),a("p",[t._v("List 接口继承于 Collection 接口，同时也是 ArrayList、LinkedList 的父类")]),t._v(" "),a("p",[t._v("Set 接口跟 List 接口处于同级的层次，也继承于 Collection 接口，同时也是 HashSet、TreeSet 的父类")]),t._v(" "),a("p",[t._v("Map 是一个支持 key-value 存储的对象，Map 不能包含重复的 key，注意 Map 不继承于 Collection 接口")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("实现类命名方式：底层数据结构 + 实现的集合接口。"),a("em",[t._v("e.g：ArrayList (数组结构 + List 接口)")])])]),t._v(" "),a("h2",{attrs:{id:"list-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list-接口"}},[t._v("#")]),t._v(" List 接口")]),t._v(" "),a("p",[t._v("List接口是 Collection接口 的子接口，List 接口定义了一种规范，要求该容器允许记录"),a("strong",[t._v("元素的添加顺")]),t._v(" "),a("strong",[t._v("序，也允许元素重复")]),t._v("。那么List接口的实现类都会遵循这一种规范")]),t._v(" "),a("h3",{attrs:{id:"常用实现类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用实现类"}},[t._v("#")]),t._v(" 常用实现类")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("ArrayList：")]),t._v(" 表示数组结构，底层采用数组实现，开发中使用最多的类。")]),t._v(" "),a("li",[a("strong",[t._v("LinkedList：")]),t._v(" 表示链表结构，表示单向链表和双向链表")]),t._v(" "),a("li",[a("strong",[t._v("Stack：")]),t._v(" 栈结构，使用数组实现，使用不多")]),t._v(" "),a("li",[a("strong",[t._v("Vector：")]),t._v(" 向量，老版的 ArrayList，使用数组实现，使用不多")])]),t._v(" "),a("h3",{attrs:{id:"常用-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用-api"}},[t._v("#")]),t._v(" 常用 API")]),t._v(" "),a("p",[a("strong",[t._v("添加操作")])]),t._v(" "),a("ul",[a("li",[a("em",[t._v("boolean add(E e)：")]),t._v(" 将元素添加到列表末尾")]),t._v(" "),a("li",[a("em",[t._v("void add(int index, E element)：")]),t._v(" 在列表的指定位置插入指定元素")]),t._v(" "),a("li",[a("em",[t._v("boolean addAll(Collection<? extends E> c)：")]),t._v(" 将指定 collection 中的所有元素都插入到列表中的指定位置")])]),t._v(" "),a("p",[a("strong",[t._v("删除操作")])]),t._v(" "),a("ul",[a("li",[a("em",[t._v("boolean remove(Object o)：")]),t._v(" 从此列表中移除第一次出现的指定元素")]),t._v(" "),a("li",[a("em",[t._v("E remove(int index)：")]),t._v(" 移除列表中指定位置的元素")]),t._v(" "),a("li",[a("em",[t._v("boolean removeAll(Collection<? extends E> c)：")]),t._v(" 从列表中移除指定 collection 中包含的其所有元素")])]),t._v(" "),a("p",[a("strong",[t._v("修改操作")])]),t._v(" "),a("ul",[a("li",[a("em",[t._v("Object set(int index, Object ele)：")]),t._v(" 修改列表中指定索引位置的元素，返回被替换的旧元素")])]),t._v(" "),a("p",[a("strong",[t._v("查询操作")])]),t._v(" "),a("ul",[a("li",[a("em",[t._v("int size()：")]),t._v(" 返回当前列表中元素个数")]),t._v(" "),a("li",[a("em",[t._v("boolean isEmpty()：")]),t._v(" 判断当前列表中元素个数是否为0")]),t._v(" "),a("li",[a("em",[t._v("Object get(int index)：")]),t._v(" 查询列表中指定索引位置对应的元素")]),t._v(" "),a("li",[a("em",[t._v("Object[] toArray()：")]),t._v(" 把列表对象转换为Object数组")]),t._v(" "),a("li",[a("em",[t._v("boolean contains(Object o)：")]),t._v(" 判断列表是否存在指定对象")])]),t._v(" "),a("h2",{attrs:{id:"arraylist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[t._v("#")]),t._v(" ArrayList")]),t._v(" "),a("p",[t._v("ArrayList 是实现了 List 接口的 可扩容数组，它的内部是基于数组实现的，不是线程安全")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" elementData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("p",[t._v("其内部定义了一个 Object 类型的数组，所以它允许存储所有类型元素")])]),t._v(" "),a("li",[a("p",[t._v("ArrayList 内部有容量的概念，用于表示该数组能存储多大的数据")])]),t._v(" "),a("li",[a("p",[t._v("ArrayList 不是线程安全的容器，使用线程安全应该使用 "),a("strong",[a("code",[t._v("Collections.synchronizedList")])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronizedList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n")])])])]),t._v(" "),a("li",[a("p",[t._v("在集合遍历中，删除添加改变集合的结构时，会出现异常")])])]),t._v(" "),a("h2",{attrs:{id:"vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[t._v("#")]),t._v(" Vector")]),t._v(" "),a("p",[t._v("Vector 同 ArrayList 一样，都是基于数组实现的，只不过 Vector 是线程安全的容器。内部每个方法使用 "),a("strong",[a("code",[t._v("synchronized")])]),t._v(" 进行同步，避免多线程引起的安全问题，但是也导致了 Vector 效率低下")]),t._v(" "),a("h2",{attrs:{id:"linkedlist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[t._v("#")]),t._v(" LinkedList")]),t._v(" "),a("p",[t._v("LinkedList 类，底层采用链表算法，实现了链表，队列，栈的数据结构。无论是链表还是队列主要\n操作的都是头和尾的元素，因此在 LinkedList 类中除了 List 接口的方法，还有很多操作头尾的方法")]),t._v(" "),a("blockquote",[a("p",[t._v("注：这个实现也不是线程安全的")])]),t._v(" "),a("h3",{attrs:{id:"常用-api-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用-api-2"}},[t._v("#")]),t._v(" 常用 API")]),t._v(" "),a("p",[a("strong",[t._v("栈操作")])]),t._v(" "),a("ul",[a("li",[a("em",[t._v("void push(Object e)：")]),t._v(" 将元素推入此列表所表示的栈。")]),t._v(" "),a("li",[a("em",[t._v("Object pop()：")]),t._v(" 从此列表所表示的栈处弹出一个元素")]),t._v(" "),a("li",[a("em",[t._v("Object peek()：")]),t._v(" 获取但不移除此列表的头（第一个元素）")])]),t._v(" "),a("p",[a("strong",[t._v("单向队列")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("会抛出异常👇")])])]),t._v(" "),a("li",[a("p",[a("em",[t._v("boolean add(Object e)：")]),t._v(" 入队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object remove()：")]),t._v(" 出队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object element()：")]),t._v(" 获取但不移除此列表的头（第一个元素）")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("不会抛出异常👇")])])]),t._v(" "),a("li",[a("p",[a("em",[t._v("boolean offer(Object e)：")]),t._v(" 入队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object poll()：")]),t._v(" 出队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object peek()：")]),t._v(" 获取但不移除此列表的头（第一个元素）")])])]),t._v(" "),a("p",[a("strong",[t._v("双向队列")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("会抛出异常👇")])])]),t._v(" "),a("li",[a("p",[a("em",[t._v("boolean addFirst(Object e)：")]),t._v(" 头部入队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("boolean addLast(Object e)：")]),t._v(" 尾部入队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object removeFirst()：")]),t._v(" 头部出队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object removeLast()：")]),t._v(" 尾部出队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object getFirst()：")]),t._v(" 返回此列表的第一个元素")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object getLast()：")]),t._v(" 返回此列表的最后一个元素")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("不会抛出异常👇")])])]),t._v(" "),a("li",[a("p",[a("em",[t._v("boolean offerFirst(Object e)：")]),t._v(" 头部入队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("boolean offerLast(Object e)：")]),t._v(" 尾部入队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object pollFirst()：")]),t._v(" 头部出队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object pollLast()：")]),t._v(" 尾部出队操作")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object peekFirst()：")]),t._v(" 返回此列表的第一个元素")])]),t._v(" "),a("li",[a("p",[a("em",[t._v("Object peekLast()：")]),t._v(" 返回此列表的最后一个元素")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("LinkedList之所以有这么多方法，是因为自身实现了多种数据结构，而不同的数据结构的操作方法\n名称不同")])]),t._v(" "),a("h2",{attrs:{id:"stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stack"}},[t._v("#")]),t._v(" Stack")]),t._v(" "),a("p",[t._v("Stack 表示栈，是 Vector 类的子类，具有先进后出的特性，拥有push（入栈），pop（出栈）方法")]),t._v(" "),a("h2",{attrs:{id:"set-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-接口"}},[t._v("#")]),t._v(" Set 接口")]),t._v(" "),a("p",[t._v("Set 是 Collection 子接口，Set 接口定义了一种规范，也就是该容器"),a("strong",[t._v("不记录元素的添加顺序，也不允")]),t._v(" "),a("strong",[t._v("许元素重复")]),t._v("，那么 Set 接口的实现类都遵循这一种规范。")]),t._v(" "),a("h3",{attrs:{id:"常用实现类-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用实现类-2"}},[t._v("#")]),t._v(" 常用实现类")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("HashSet：")]),t._v(" 底层采用哈希表实现，开发中使用较多的实现类")]),t._v(" "),a("li",[a("strong",[t._v("TreeSet：")]),t._v(" 底层采用红黑树实现，可以对集合中元素排序，默认自然排序")])]),t._v(" "),a("h3",{attrs:{id:"常用-api-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用-api-3"}},[t._v("#")]),t._v(" 常用 API")]),t._v(" "),a("ul",[a("li",[a("em",[t._v("boolean add(Object e)")])]),t._v(" "),a("li",[a("em",[t._v("boolean remove(Object e)")])]),t._v(" "),a("li",[a("em",[t._v("boolean contains(Object e)")])]),t._v(" "),a("li",[a("em",[t._v("void clear()")])]),t._v(" "),a("li",[a("em",[t._v("int size()")])])]),t._v(" "),a("h2",{attrs:{id:"hashset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[t._v("#")]),t._v(" HashSet")]),t._v(" "),a("p",[t._v("HashSet 是 Set 接口的实现类，底层采用哈希表实现，不能保证元素的有序，保证了元素的唯一，运行存储 NULL 元素，注意 它不是线程安全的容器。")]),t._v(" "),a("p",[t._v("查看源码可知，其内部是 HashMap 的实例")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" map"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashSet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    map "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"底层工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#底层工作原理"}},[t._v("#")]),t._v(" 底层工作原理")]),t._v(" "),a("p",[t._v("内部使用哈希表实现，每个元素需要先计算 "),a("strong",[t._v("哈希值")]),t._v("，再通过 "),a("strong",[t._v("散列函数")]),t._v(" 计算出元素的位置")]),t._v(" "),a("p",[t._v("如果该位置存在元素，则去除该位置上 "),a("strong",[t._v("链表")]),t._v(" 的所有元素，通过 "),a("strong",[t._v("equals")]),t._v(" 方法依次比较，如果有重复的元素，则不添加，没有重复的元素，则在其 "),a("strong",[t._v("链表")]),t._v(" 后面添加，如下图👇")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/LRMSB3ygqTSg.png?imageslim",alt:"mark"}})]),t._v(" "),a("h3",{attrs:{id:"hashcode-和-equals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashcode-和-equals"}},[t._v("#")]),t._v(" hashCode 和 equals")]),t._v(" "),a("p",[t._v("根据其工作原理，我们可以得知，在哈希表中元素的 hashCode 和 equals 方法很重要")]),t._v(" "),a("p",[t._v("每一个存储到好像表中的对象，都得覆盖hashCode和equals方法用来判断是否是同一个对象，一\n般的，根据对象的字段数据比较来判断，通常情况下equals为true的时候hashCode也应该相等")]),t._v(" "),a("h2",{attrs:{id:"treeset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[t._v("#")]),t._v(" TreeSet")]),t._v(" "),a("p",[t._v("TreeSet 是 Set 接口的实现类，底层采用红黑树算法实现，会对存储的元素进行排序，默认是自然排序(从小到大)")]),t._v(" "),a("p",[t._v("注意：TreeSet 不允许存储 NULL 值")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210426/MnWGajJtO982.png?imageslim",alt:"mark"}})]),t._v(" "),a("ul",[a("li",[t._v("红黑树存储的时候是左边的存较小的元素，右边存储较大的元素")]),t._v(" "),a("li",[t._v("由于 TreeSet 是平衡二叉树，如果树不平衡，会对节点进行调整")])]),t._v(" "),a("p",[t._v("当我们使用 TreeSet 存储元素时，此时要求元素必须具备 "),a("strong",[t._v("比较大小")]),t._v(" 的能力，也就是实现 "),a("em",[t._v("java.util.Comparable")]),t._v(" 接口")]),t._v(" "),a("h3",{attrs:{id:"comparable-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#comparable-接口"}},[t._v("#")]),t._v(" Comparable 接口")]),t._v(" "),a("p",[t._v("TreeSet 会调用元素的 "),a("code",[t._v("compareTo")]),t._v(" 方法来比较元素的大小关系,然后将集合元素按照升序排列")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparable")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareTo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("比较规则，拿当前元素和另一个元素比较：")]),t._v(" "),a("ul",[a("li",[t._v("返回负数，当前元素小")]),t._v(" "),a("li",[t._v("返回正数，当前元素大")]),t._v(" "),a("li",[t._v("等于 0，一样，此时认为两个为同一个对象")])]),t._v(" "),a("p",[t._v("如果我们存储进 TreeSet 集合中的元素没有 比较功能，可以让该元素实现 Comparable 接口，并\n覆盖compareTo方法，在该方法编写比较规则，否则添加会报错。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ComparableExample")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("java"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lang"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),t._v("Comparable")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("User")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareTo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ComparableExample")]),t._v(" o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... 比较规则")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"comparator-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#comparator-接口"}},[t._v("#")]),t._v(" Comparator 接口")]),t._v(" "),a("p",[t._v("当原有的排序规则不满足我们的需求时，我们可以提供一个 "),a("strong",[t._v("外部比较器(Comparator)")]),t._v(" 通过 TreeSet 构造器传入该比较器的实现类")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparator")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" o1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" o2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用方法：")]),t._v(" "),a("p",[t._v("因为 Comparator 实现类只是用一次，我们可以使用匿名内部类，JDK8 提供了 lambda 表达式，我们可以简写")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需求：通过比较字符串长度")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 原有的 String 自带的比较规则不满足需求，使用 Comparator")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeSet")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" treeSet "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeSet")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparator")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("comparingInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("length")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    treeSet"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"abc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    treeSet"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"apple"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    treeSet"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"zeng"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("treeSet"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"map-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-接口"}},[t._v("#")]),t._v(" Map 接口")]),t._v(" "),a("p",[t._v("Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value")]),t._v(" "),a("p",[t._v("Map 结构如下👇")]),t._v(" "),a("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://media.zenghr.cn/blog/img/20210426/GkR0fNhc2UKS.png?imageslim",alt:"mark"}}),t._v(" "),a("p",[t._v("其实能看出一个 Map 其实就由多个 key-value（键值对）组成的，每一个键值对我们使用Entry表示，键（key值）不可重复，value值可以重复")]),t._v(" "),a("p",[t._v("所以也可以说 Map 的 key 是存储在 set 集合中，不可重复")]),t._v(" "),a("h3",{attrs:{id:"常用实现类-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用实现类-3"}},[t._v("#")]),t._v(" 常用实现类")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("HashMap：")]),t._v(" 底层基于哈希表算法")]),t._v(" "),a("li",[a("strong",[t._v("TreeMap：")]),t._v(" 底层基于红黑树算法")])]),t._v(" "),a("h3",{attrs:{id:"常用-api-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用-api-4"}},[t._v("#")]),t._v(" 常用 API")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("boolean put(Object key, Object value)： 存储一个键值对到Map中")])]),t._v(" "),a("li",[t._v("boolean putAll(Map m)： 把 m 中的所有键值对添加到当前Map中")]),t._v(" "),a("li",[a("strong",[t._v("Object remove(Object key)： 从Map中删除指定key的键值对，并返回被删除key对应的value")])]),t._v(" "),a("li",[t._v("boolean isEmpty()： 判断当前Map中键值对个数是否为0")]),t._v(" "),a("li",[a("strong",[t._v("Object get(Object key)： 返回Map中指定key对应的value值，如果不存在该key，返回null")])]),t._v(" "),a("li",[t._v("boolean containsKey(Object key)： 判断Map中是否包含指定 key")]),t._v(" "),a("li",[t._v("boolean containsValue(Object value)： 判断Map中是否包含指定 value")]),t._v(" "),a("li",[a("strong",[t._v("Set keySet()： 返回Map中所有 key 所组成的Set集合")])]),t._v(" "),a("li",[t._v("Collection values()： 返回Map中所有 value 所组成的Set集合")]),t._v(" "),a("li",[t._v("Set entrySet()： 返回Map中所有键值对所组成的Set集合")])]),t._v(" "),a("h2",{attrs:{id:"hashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[t._v("#")]),t._v(" HashMap")]),t._v(" "),a("p",[t._v("HashMap 底层基于哈希表算法，Map中存储的 key 对象的 hashCode 值决定了在哈希表中的存储位\n置，因为Map中的 key 是 Set，所以不能保证添加的先后顺序，也不允许重复")]),t._v(" "),a("p",[t._v("因为 HashSet 内部使用的就是 HashMap 所以两两者原理一致，HashSet 只是在 HashMap 上封装了一层，其底层工作原理一致")]),t._v(" "),a("h2",{attrs:{id:"treemap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[t._v("#")]),t._v(" TreeMap")]),t._v(" "),a("p",[t._v("TreeMap底层基于红黑树算法，因为Map中的 key 是 Set，所以不能保证添加的先后顺序，也不允\n许重复，但是Map中存储的 key 会默认使用自然排序（从小到大），和 TreeSet 一样，除了可以使用自然\n排序也可以自定义排序")]),t._v(" "),a("p",[t._v("底层工作原理和 TreeSet 一致")]),t._v(" "),a("h2",{attrs:{id:"集合框架-工具类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合框架-工具类"}},[t._v("#")]),t._v(" 集合框架 工具类")]),t._v(" "),a("h3",{attrs:{id:"arrays"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arrays"}},[t._v("#")]),t._v(" Arrays")]),t._v(" "),a("p",[t._v("Arrays类是数组的工具类，其中包含对数组的拷贝、格式化、排序查询等方法")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Arrays.copyOf(T[] original, int newLength)：")]),t._v(" 数组拷贝")]),t._v(" "),a("li",[t._v("System.arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length)：System类下的数组拷贝方法")]),t._v(" "),a("li",[a("em",[a("strong",[t._v("Arrays.toString()：")])]),t._v(" 数组格式化输出")]),t._v(" "),a("li",[a("strong",[t._v("Arrays.sort()：")]),t._v(" 数组排序，内部使用快速排序")]),t._v(" "),a("li",[a("strong",[t._v("Arrays.binarySearch：")]),t._v(" 二分查找")]),t._v(" "),a("li",[a("strong",[t._v("asList()：")]),t._v(" 将数组转化为 List 集合，但是"),a("strong",[t._v("不可改变长度")])])]),t._v(" "),a("h3",{attrs:{id:"collections"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collections"}},[t._v("#")]),t._v(" Collections")]),t._v(" "),a("p",[t._v("Collections 是一个操作 Collection（Set、 List ）和 Map 等集合的工具类")]),t._v(" "),a("p",[a("strong",[t._v("常用 API")])]),t._v(" "),a("p",[a("em",[t._v("排序操作")])]),t._v(" "),a("ul",[a("li",[t._v("reverse(List)： 反转 List 中元素的顺序")]),t._v(" "),a("li",[t._v("shuffle(List)： 对 List 集合元素进行随机排序")]),t._v(" "),a("li",[a("strong",[t._v("sort(List)： 根据元素的自然顺序对指定 List 集合元素按升序排序")])]),t._v(" "),a("li",[t._v("sort(List， Comparator)： 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序")]),t._v(" "),a("li",[t._v("swap(List， int， int)： 将指定 list 集合中的 i 处元素和 j 处元素进行交换")])]),t._v(" "),a("p",[a("em",[t._v("查找和替换")])]),t._v(" "),a("ul",[a("li",[t._v("Object max(Collection)： 根据元素的自然顺序，返回给定集合中的最大元素")]),t._v(" "),a("li",[t._v("Object max(Collection， Comparator)： 根据 Comparator 指定的顺序，返回给定集合中的最大元素")]),t._v(" "),a("li",[t._v("Object min(Collection)")]),t._v(" "),a("li",[t._v("Object min(Collection， Comparator)")]),t._v(" "),a("li",[t._v("int frequency(Collection， Object)： 返回指定集合中指定元素的出现次数")]),t._v(" "),a("li",[a("strong",[t._v("void copy(List dest,List src)：将src中的内容复制到dest中")])]),t._v(" "),a("li",[t._v("boolean replaceAll(List list， Object oldVal， Object newVal)： 使用新值替换List 对象的所有旧值")])]),t._v(" "),a("p",[a("strong",[t._v("解决多线程并发访问集合时的线程安全问题")])]),t._v(" "),a("p",[t._v("Collections提供了基本每种集合类型都有的方法: "),a("strong",[a("code",[t._v("synchronizedXxx()")])]),t._v(" 方法,以解决多个线程同时操作一个集合的并发问题")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//通过如下的方法保证List的线程安全性")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronizedList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);