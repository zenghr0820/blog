(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{430:function(s,e,t){"use strict";t.r(e);var a=t(2),n=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"redis-持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[s._v("#")]),s._v(" Redis 持久化机制")]),s._v(" "),e("blockquote",[e("p",[s._v("Redis是一个支持持久化的内存数据库，也就是说 redis 需要经常将内存中的数据同步到硬盘来保证持久化")]),s._v(" "),e("p",[s._v("Redis持久化主要分为两种方式，分别是RDB和AOF，当然实际场景下还会使用这两种的混合模式")])]),s._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),e("p",[s._v("Redis的数据正常都是存储在内存内，如果宕机突然发生，数据就会全部丢失，因此需要提供一种方式保证 redis 的数据不会因为故障而丢失，这种机制就是 "),e("strong",[s._v("redis 的持久化机制")])]),s._v(" "),e("p",[s._v("目前 Redis 主流的持久化机制有两种：RDB 方式 和 AOF 方式")]),s._v(" "),e("h2",{attrs:{id:"rdb-持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb-持久化"}},[s._v("#")]),s._v(" RDB 持久化")]),s._v(" "),e("blockquote",[e("p",[s._v("RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为 "),e("strong",[s._v("手动触发")]),s._v(" 和 "),e("strong",[s._v("自动触发")])])]),s._v(" "),e("h3",{attrs:{id:"手动触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手动触发"}},[s._v("#")]),s._v(" 手动触发")]),s._v(" "),e("p",[s._v("手动触发分别对应 save 和 bgsave 命令")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("save命令")]),s._v("：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间"),e("strong",[s._v("阻塞")]),s._v("，线上环境不建议使用")]),s._v(" "),e("li",[e("strong",[s._v("bgsave命令")]),s._v("：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短")])]),s._v(" "),e("blockquote",[e("p",[s._v("bgsave 命令是针对 save 阻塞问题做的优化，因此Redis内部所有涉及到RDB操作都采用 bgsave 的方式，而 "),e("s",[s._v("save")]),s._v(" 命令可以废弃")])]),s._v(" "),e("p",[s._v("bgsave流程图如下所示👇")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210802/eFa8oF.png",alt:"eFa8oF"}})]),s._v(" "),e("p",[s._v("具体流程如下：")]),s._v(" "),e("ul",[e("li",[s._v("redis 客户端执行 bgsave 命令或者自动触发bgsave命令；")]),s._v(" "),e("li",[s._v("主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；")]),s._v(" "),e("li",[s._v("如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；")]),s._v(" "),e("li",[s._v("子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；")]),s._v(" "),e("li",[s._v("同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）")])]),s._v(" "),e("h3",{attrs:{id:"自动触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动触发"}},[s._v("#")]),s._v(" 自动触发")]),s._v(" "),e("blockquote",[e("p",[s._v("在以下4种情况时会自动触发")])]),s._v(" "),e("ul",[e("li",[e("p",[s._v("redis.conf中配置"),e("code",[s._v("save m n")]),s._v("，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；")])]),s._v(" "),e("li",[e("p",[s._v("主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；")])]),s._v(" "),e("li",[e("p",[s._v("执行 "),e("strong",[s._v("debug reload")]),s._v(" 命令重新加载 redis 时也会触发bgsave操作；")])]),s._v(" "),e("li",[e("p",[s._v("默认情况下执行shutdown命令时，如果没有开启 aof持久化，那么也会触发bgsave操作")])])]),s._v(" "),e("h3",{attrs:{id:"redis-conf中配置rdb"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-conf中配置rdb"}},[s._v("#")]),s._v(" redis.conf中配置RDB")]),s._v(" "),e("ul",[e("li",[s._v("配置设置自动做快照持久化方式")])]),s._v(" "),e("div",{staticClass:"language-sh extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 周期性执行条件的设置格式为")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("seconds"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("changes"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 默认的设置为：")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("900")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("300")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 以下设置方式为关闭RDB快照功能")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('""')]),s._v("\n")])])]),e("p",[s._v("以上三项默认信息设置代表的意义是：")]),s._v(" "),e("ul",[e("li",[s._v("如果900秒内有1条Key信息发生变化，则进行快照；")]),s._v(" "),e("li",[s._v("如果300秒内有10条Key信息发生变化，则进行快照；")]),s._v(" "),e("li",[s._v("如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整")])]),s._v(" "),e("div",{staticClass:"language-sh extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 文件名称")]),s._v("\ndbfilename dump.rdb\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 文件保存路径")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /home/work/app/redis/data/\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 如果持久化出错，主进程是否停止写入")]),s._v("\nstop-writes-on-bgsave-error "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 是否压缩")]),s._v("\nrdbcompression "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 导入时是否检查")]),s._v("\nrdbchecksum "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])])]),e("ul",[e("li",[e("p",[e("strong",[s._v("dbfilename：")]),s._v(" 配置文件名，可以通过执行 "),e("code",[s._v("config set dir {newDir}")]),s._v(" 和 "),e("code",[s._v("config set dbfilename {newFileName}")]),s._v(" 运行期动态执行，当下次运行时RDB文件会保存到新目录")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("dir：")]),s._v(" 可以通过执行 "),e("code",[s._v("config set dir {newDir}")]),s._v(" 和 "),e("code",[s._v("config set dbfilename {newFileName}")]),s._v(" 运行期动态执行，当下次运行时RDB文件会保存到新目录")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("压缩：")]),s._v(" Redis默认采用 "),e("strong",[s._v("LZF算法")]),s._v(" 对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 "),e("code",[s._v("config set rdbcompression {yes|no}")]),s._v(" 动态修改。")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("校验：")]),s._v(" 如果Redis加载损坏的RDB文件时拒绝启动，这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为 no")])])]),s._v(" "),e("h3",{attrs:{id:"rdb-的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb-的优缺点"}},[s._v("#")]),s._v(" RDB 的优缺点")]),s._v(" "),e("ul",[e("li",[e("p",[e("strong",[s._v("优点：")])]),s._v(" "),e("ul",[e("li",[s._v("RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景")]),s._v(" "),e("li",[s._v("Redis加载RDB文件恢复数据要远远快于AOF方式")])])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("缺点：")])]),s._v(" "),e("ul",[e("li",[s._v("RDB方式实时性不够，无法做到秒级的持久化；")]),s._v(" "),e("li",[s._v("每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；")]),s._v(" "),e("li",[s._v("RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；")]),s._v(" "),e("li",[s._v("版本兼容RDB文件问题")])]),s._v(" "),e("p",[s._v("针对RDB不适合实时持久化的问题，Redis提供了 "),e("strong",[s._v("AOF持久化")]),s._v(" 方式来解决")])])]),s._v(" "),e("h2",{attrs:{id:"aof-持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof-持久化"}},[s._v("#")]),s._v(" AOF 持久化")]),s._v(" "),e("blockquote",[e("p",[s._v("AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。")]),s._v(" "),e("p",[s._v("AOF的主要作用是解决了数据持久化的实时性，目前已经是 "),e("strong",[s._v("Redis持久化的主流方式")])])]),s._v(" "),e("p",[s._v("而AOF日志采用写后日志，即 "),e("strong",[s._v("先写内存，后写日志")])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210802/a20AVK.jpeg",alt:"a20AVK"}})]),s._v(" "),e("p",[s._v("Redis要求高性能，采用写日志有两方面好处：")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("避免额外的检查开销")]),s._v("：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。")]),s._v(" "),e("li",[s._v("不会阻塞当前的写操作")])]),s._v(" "),e("p",[s._v("但这种方式存在潜在风险：")]),s._v(" "),e("ul",[e("li",[s._v("如果命令执行完成，写日志之前宕机了，会丢失数据。")]),s._v(" "),e("li",[s._v("主线程写磁盘压力大，导致写盘慢，阻塞后续操作")])]),s._v(" "),e("h3",{attrs:{id:"如何实现-aof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何实现-aof"}},[s._v("#")]),s._v(" 如何实现 AOF")]),s._v(" "),e("p",[s._v("AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）")]),s._v(" "),e("ul",[e("li",[e("p",[e("strong",[s._v("命令追加")]),s._v(" 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 "),e("strong",[s._v("aof_buf")]),s._v(" 缓冲区。")])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("文件写入和同步")]),s._v(" 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略")])])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210802/LATaFC.jpeg",alt:"LATaFC"}})]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("Always")]),s._v(" - 同步写回：每个写命令执行完，立马同步地将日志写回磁盘")]),s._v(" "),e("li",[e("strong",[e("code",[s._v("Everysec(推荐)")])]),s._v(" - 每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘")]),s._v(" "),e("li",[e("strong",[s._v("No")]),s._v("  - 操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘(不推荐)")])]),s._v(" "),e("h3",{attrs:{id:"conf-配置aof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conf-配置aof"}},[s._v("#")]),s._v(" Conf 配置AOF")]),s._v(" "),e("p",[s._v("默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：")]),s._v(" "),e("div",{staticClass:"language-sh extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# appendonly参数开启AOF持久化")]),s._v("\nappendonly no\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF持久化的文件名，默认是appendonly.aof")]),s._v("\nappendfilename "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"appendonly.aof"')]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" ./\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 同步策略")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# appendfsync always")]),s._v("\nappendfsync everysec\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# appendfsync no")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# aof重写期间是否同步")]),s._v("\nno-appendfsync-on-rewrite no\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 重写触发配置")]),s._v("\nauto-aof-rewrite-percentage "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v("\nauto-aof-rewrite-min-size 64mb\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 加载aof出错如何处理")]),s._v("\naof-load-truncated "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 文件重写策略")]),s._v("\naof-rewrite-incremental-fsync "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])])]),e("p",[s._v("以下是Redis中关于AOF的主要配置信息：")]),s._v(" "),e("ul",[e("li",[e("p",[e("code",[s._v("appendonly")]),s._v("：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("appendfilename")]),s._v("：这个参数项很好理解了，就是AOF文件的名字")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("appendfsync")]),s._v("：这个参数项是AOF功能最重要的设置项之一，主要用于设置操作命令向AOF文件中同步的策略")])])]),s._v(" "),e("h2",{attrs:{id:"rdb和aof混合方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb和aof混合方式"}},[s._v("#")]),s._v(" RDB和AOF混合方式")]),s._v(" "),e("blockquote",[e("p",[s._v("Redis 4.0 中提出了一个"),e("strong",[s._v("混合使用 AOF 日志和内存快照")]),s._v("的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作")])]),s._v(" "),e("p",[s._v("这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。")]),s._v(" "),e("p",[s._v("如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://media.zenghr.cn/blog/img/20210802/yBKz08.jpeg",alt:"yBKz08"}})]),s._v(" "),e("p",[s._v("这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多")]),s._v(" "),e("h2",{attrs:{id:"参考文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[s._v("#")]),s._v(" 参考文档")]),s._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/ybyn/p/14157568.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.cnblogs.com/ybyn/p/14157568.html"),e("OutboundLink")],1)])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000015983518",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://segmentfault.com/a/1190000015983518"),e("OutboundLink")],1)])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://blog.csdn.net/qq_41434612/article/details/108791437",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://blog.csdn.net/qq_41434612/article/details/108791437"),e("OutboundLink")],1)])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/liang24/p/14180036.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.cnblogs.com/liang24/p/14180036.html"),e("OutboundLink")],1)])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/d3ba7b8ad964",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.jianshu.com/p/d3ba7b8ad964"),e("OutboundLink")],1)])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://blog.csdn.net/liupeifeng3514/article/details/79048767",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://blog.csdn.net/liupeifeng3514/article/details/79048767"),e("OutboundLink")],1)])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html"),e("OutboundLink")],1)])])])])}),[],!1,null,null,null);e.default=n.exports}}]);