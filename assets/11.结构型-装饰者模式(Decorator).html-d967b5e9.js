const e=JSON.parse('{"key":"v-0c84f533","path":"/dev-guide/design/11.%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F(Decorator).html","title":"结构型 - 装饰器模式(Decorator)","lang":"zh-CN","frontmatter":{"title":"结构型 - 装饰器模式(Decorator)","date":"2021-05-07T21:30:12.000Z","re":"dev-decorator-pattern","star":true,"tag":["设计模式"],"category":["设计模式"],"description":"装饰(Decorator) 提示 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式 装饰器模式介绍 装饰器器的核心就是在 不改变原有类 的基础上给类新增功能 通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会过多等问题。但是使用装饰器模式会是另外一种思路更为灵活，可以避免继承导致的子类过多","permalink":"/passages/dev-decorator-pattern.html","head":[["meta",{"property":"og:url","content":"https://blog.zenghr.cn/passages/dev-decorator-pattern.html"}],["meta",{"property":"og:site_name","content":"Zenghr"}],["meta",{"property":"og:title","content":"结构型 - 装饰器模式(Decorator)"}],["meta",{"property":"og:description","content":"装饰(Decorator) 提示 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式 装饰器模式介绍 装饰器器的核心就是在 不改变原有类 的基础上给类新增功能 通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会过多等问题。但是使用装饰器模式会是另外一种思路更为灵活，可以避免继承导致的子类过多"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Zenghr"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2021-05-07T21:30:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"结构型 - 装饰器模式(Decorator)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-05-07T21:30:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zenghr\\"}]}"]]},"headers":[{"level":2,"title":"装饰器模式介绍","slug":"装饰器模式介绍","link":"#装饰器模式介绍","children":[]},{"level":2,"title":"装饰器的结构","slug":"装饰器的结构","link":"#装饰器的结构","children":[]},{"level":2,"title":"装饰器的案例模拟","slug":"装饰器的案例模拟","link":"#装饰器的案例模拟","children":[]},{"level":2,"title":"装饰器模式的应用场景","slug":"装饰器模式的应用场景","link":"#装饰器模式的应用场景","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{},"readingTime":{"minutes":3.61,"words":1083},"filePathRelative":"dev-guide/design/11.结构型-装饰者模式(Decorator).md","localizedDate":"2021年5月7日","excerpt":"<h1> 装饰(Decorator)</h1>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式</p>\\n</div>\\n<h2> 装饰器模式介绍</h2>\\n<p>装饰器器的核心就是在 <strong>不改变原有类</strong> 的基础上给类新增功能</p>\\n<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会过多等问题。但是使用装饰器模式会是另外一种思路更为灵活，可以避免继承导致的子类过多</p>","autoDesc":true}');export{e as data};
