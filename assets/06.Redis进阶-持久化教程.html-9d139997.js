import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as r,c as o,d as e,e as s,b as a,a as d}from"./app-0bf44ca3.js";const t={},c=d(`<h1 id="redis-持久化机制" tabindex="-1"><a class="header-anchor" href="#redis-持久化机制" aria-hidden="true">#</a> Redis 持久化机制</h1><blockquote><p>Redis是一个支持持久化的内存数据库，也就是说 redis 需要经常将内存中的数据同步到硬盘来保证持久化</p><p>Redis持久化主要分为两种方式，分别是RDB和AOF，当然实际场景下还会使用这两种的混合模式</p></blockquote><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>Redis的数据正常都是存储在内存内，如果宕机突然发生，数据就会全部丢失，因此需要提供一种方式保证 redis 的数据不会因为故障而丢失，这种机制就是 <strong>redis 的持久化机制</strong></p><p>目前 Redis 主流的持久化机制有两种：RDB 方式 和 AOF 方式</p><h2 id="rdb-持久化" tabindex="-1"><a class="header-anchor" href="#rdb-持久化" aria-hidden="true">#</a> RDB 持久化</h2><blockquote><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为 <strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h3 id="手动触发" tabindex="-1"><a class="header-anchor" href="#手动触发" aria-hidden="true">#</a> 手动触发</h3><p>手动触发分别对应 save 和 bgsave 命令</p><ul><li><strong>save命令</strong>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</li><li><strong>bgsave命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</li></ul><blockquote><p>bgsave 命令是针对 save 阻塞问题做的优化，因此Redis内部所有涉及到RDB操作都采用 bgsave 的方式，而 <s>save</s> 命令可以废弃</p></blockquote><p>bgsave流程图如下所示👇</p><figure><img src="https://media.zenghr.cn/blog/img/20210802/eFa8oF.png" alt="eFa8oF" tabindex="0" loading="lazy"><figcaption>eFa8oF</figcaption></figure><p>具体流程如下：</p><ul><li>redis 客户端执行 bgsave 命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）</li></ul><h3 id="自动触发" tabindex="-1"><a class="header-anchor" href="#自动触发" aria-hidden="true">#</a> 自动触发</h3><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li><p>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</p></li><li><p>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</p></li><li><p>执行 <strong>debug reload</strong> 命令重新加载 redis 时也会触发bgsave操作；</p></li><li><p>默认情况下执行shutdown命令时，如果没有开启 aof持久化，那么也会触发bgsave操作</p></li></ul><h3 id="redis-conf中配置rdb" tabindex="-1"><a class="header-anchor" href="#redis-conf中配置rdb" aria-hidden="true">#</a> redis.conf中配置RDB</h3><ul><li>配置设置自动做快照持久化方式</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 周期性执行条件的设置格式为</span>
save <span class="token operator">&lt;</span>seconds<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>changes<span class="token operator">&gt;</span>

<span class="token comment"># 默认的设置为：</span>
save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span>

<span class="token comment"># 以下设置方式为关闭RDB快照功能</span>
save <span class="token string">&quot;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照；</li><li>如果300秒内有10条Key信息发生变化，则进行快照；</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 文件名称</span>
dbfilename dump.rdb
<span class="token comment"># 文件保存路径</span>
<span class="token function">dir</span> /home/work/app/redis/data/
<span class="token comment"># 如果持久化出错，主进程是否停止写入</span>
stop-writes-on-bgsave-error <span class="token function">yes</span>
<span class="token comment"># 是否压缩</span>
rdbcompression <span class="token function">yes</span>
<span class="token comment"># 导入时是否检查</span>
rdbchecksum <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>dbfilename：</strong> 配置文件名，可以通过执行 <code>config set dir {newDir}</code> 和 <code>config set dbfilename {newFileName}</code> 运行期动态执行，当下次运行时RDB文件会保存到新目录</p></li><li><p><strong>dir：</strong> 可以通过执行 <code>config set dir {newDir}</code> 和 <code>config set dbfilename {newFileName}</code> 运行期动态执行，当下次运行时RDB文件会保存到新目录</p></li><li><p><strong>压缩：</strong> Redis默认采用 <strong>LZF算法</strong> 对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 <code>config set rdbcompression {yes|no}</code> 动态修改。</p></li><li><p><strong>校验：</strong> 如果Redis加载损坏的RDB文件时拒绝启动，这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为 no</p></li></ul><h3 id="rdb-的优缺点" tabindex="-1"><a class="header-anchor" href="#rdb-的优缺点" aria-hidden="true">#</a> RDB 的优缺点</h3><ul><li><p><strong>优点：</strong></p><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题</li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了 <strong>AOF持久化</strong> 方式来解决</p></li></ul><h2 id="aof-持久化" tabindex="-1"><a class="header-anchor" href="#aof-持久化" aria-hidden="true">#</a> AOF 持久化</h2><blockquote><p>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。</p><p>AOF的主要作用是解决了数据持久化的实时性，目前已经是 <strong>Redis持久化的主流方式</strong></p></blockquote><p>而AOF日志采用写后日志，即 <strong>先写内存，后写日志</strong></p><figure><img src="https://media.zenghr.cn/blog/img/20210802/a20AVK.jpeg" alt="a20AVK" tabindex="0" loading="lazy"><figcaption>a20AVK</figcaption></figure><p>Redis要求高性能，采用写日志有两方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作</li></ul><h3 id="如何实现-aof" tabindex="-1"><a class="header-anchor" href="#如何实现-aof" aria-hidden="true">#</a> 如何实现 AOF</h3><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）</p><ul><li><p><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 <strong>aof_buf</strong> 缓冲区。</p></li><li><p><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略</p></li></ul><figure><img src="https://media.zenghr.cn/blog/img/20210802/LATaFC.jpeg" alt="LATaFC" tabindex="0" loading="lazy"><figcaption>LATaFC</figcaption></figure><ul><li><strong>Always</strong> - 同步写回：每个写命令执行完，立马同步地将日志写回磁盘</li><li><strong><code>Everysec(推荐)</code></strong> - 每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</li><li><strong>No</strong> - 操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘(不推荐)</li></ul><h3 id="conf-配置aof" tabindex="-1"><a class="header-anchor" href="#conf-配置aof" aria-hidden="true">#</a> Conf 配置AOF</h3><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># appendonly参数开启AOF持久化</span>
appendonly no

<span class="token comment"># AOF持久化的文件名，默认是appendonly.aof</span>
appendfilename <span class="token string">&quot;appendonly.aof&quot;</span>

<span class="token comment"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span>
<span class="token function">dir</span> ./

<span class="token comment"># 同步策略</span>
<span class="token comment"># appendfsync always</span>
appendfsync everysec
<span class="token comment"># appendfsync no</span>

<span class="token comment"># aof重写期间是否同步</span>
no-appendfsync-on-rewrite no

<span class="token comment"># 重写触发配置</span>
auto-aof-rewrite-percentage <span class="token number">100</span>
auto-aof-rewrite-min-size 64mb

<span class="token comment"># 加载aof出错如何处理</span>
aof-load-truncated <span class="token function">yes</span>

<span class="token comment"># 文件重写策略</span>
aof-rewrite-incremental-fsync <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是Redis中关于AOF的主要配置信息：</p><ul><li><p><code>appendonly</code>：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p></li><li><p><code>appendfilename</code>：这个参数项很好理解了，就是AOF文件的名字</p></li><li><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置操作命令向AOF文件中同步的策略</p></li></ul><h2 id="rdb和aof混合方式" tabindex="-1"><a class="header-anchor" href="#rdb和aof混合方式" aria-hidden="true">#</a> RDB和AOF混合方式</h2><blockquote><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作</p></blockquote><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了</p><figure><img src="https://media.zenghr.cn/blog/img/20210802/yBKz08.jpeg" alt="yBKz08" tabindex="0" loading="lazy"><figcaption>yBKz08</figcaption></figure><p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2>`,52),p={href:"https://www.cnblogs.com/ybyn/p/14157568.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://segmentfault.com/a/1190000015983518",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/qq_41434612/article/details/108791437",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.cnblogs.com/liang24/p/14180036.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.jianshu.com/p/d3ba7b8ad964",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.csdn.net/liupeifeng3514/article/details/79048767",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html",target:"_blank",rel:"noopener noreferrer"};function f(k,_){const n=l("ExternalLinkIcon");return r(),o("div",null,[c,e("ul",null,[e("li",null,[e("p",null,[e("a",p,[s("https://www.cnblogs.com/ybyn/p/14157568.html"),a(n)])])]),e("li",null,[e("p",null,[e("a",u,[s("https://segmentfault.com/a/1190000015983518"),a(n)])])]),e("li",null,[e("p",null,[e("a",b,[s("https://blog.csdn.net/qq_41434612/article/details/108791437"),a(n)])])]),e("li",null,[e("p",null,[e("a",m,[s("https://www.cnblogs.com/liang24/p/14180036.html"),a(n)])])]),e("li",null,[e("p",null,[e("a",g,[s("https://www.jianshu.com/p/d3ba7b8ad964"),a(n)])])]),e("li",null,[e("p",null,[e("a",h,[s("https://blog.csdn.net/liupeifeng3514/article/details/79048767"),a(n)])])]),e("li",null,[e("p",null,[e("a",v,[s("https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html"),a(n)])])])])])}const A=i(t,[["render",f],["__file","06.Redis进阶-持久化教程.html.vue"]]);export{A as default};
