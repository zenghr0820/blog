import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-DBpUl-eW.js";const l={};function t(p,s){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="redis-持久化机制" tabindex="-1"><a class="header-anchor" href="#redis-持久化机制"><span>Redis 持久化机制</span></a></h1><blockquote><p>Redis是一个支持持久化的内存数据库，也就是说 redis 需要经常将内存中的数据同步到硬盘来保证持久化</p><p>Redis持久化主要分为两种方式，分别是RDB和AOF，当然实际场景下还会使用这两种的混合模式</p></blockquote><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>Redis的数据正常都是存储在内存内，如果宕机突然发生，数据就会全部丢失，因此需要提供一种方式保证 redis 的数据不会因为故障而丢失，这种机制就是 <strong>redis 的持久化机制</strong></p><p>目前 Redis 主流的持久化机制有两种：RDB 方式 和 AOF 方式</p><h2 id="rdb-持久化" tabindex="-1"><a class="header-anchor" href="#rdb-持久化"><span>RDB 持久化</span></a></h2><blockquote><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为 <strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h3 id="手动触发" tabindex="-1"><a class="header-anchor" href="#手动触发"><span>手动触发</span></a></h3><p>手动触发分别对应 save 和 bgsave 命令</p><ul><li><strong>save命令</strong>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</li><li><strong>bgsave命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</li></ul><blockquote><p>bgsave 命令是针对 save 阻塞问题做的优化，因此Redis内部所有涉及到RDB操作都采用 bgsave 的方式，而 <s>save</s> 命令可以废弃</p></blockquote><p>bgsave流程图如下所示👇</p><p><img src="https://media.zenghr.cn/blog/img/20210802/eFa8oF.png" alt="eFa8oF"></p><p>具体流程如下：</p><ul><li>redis 客户端执行 bgsave 命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）</li></ul><h3 id="自动触发" tabindex="-1"><a class="header-anchor" href="#自动触发"><span>自动触发</span></a></h3><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li><p>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</p></li><li><p>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</p></li><li><p>执行 <strong>debug reload</strong> 命令重新加载 redis 时也会触发bgsave操作；</p></li><li><p>默认情况下执行shutdown命令时，如果没有开启 aof持久化，那么也会触发bgsave操作</p></li></ul><h3 id="redis-conf中配置rdb" tabindex="-1"><a class="header-anchor" href="#redis-conf中配置rdb"><span>redis.conf中配置RDB</span></a></h3><ul><li>配置设置自动做快照持久化方式</li></ul><div class="language-sh" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 周期性执行条件的设置格式为</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">second</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">s&gt; &lt;</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">change</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">s&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 默认的设置为：</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 900</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 300</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 10</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 60</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 10000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 以下设置方式为关闭RDB快照功能</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> &quot;&quot;</span></span></code></pre></div><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照；</li><li>如果300秒内有10条Key信息发生变化，则进行快照；</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整</li></ul><div class="language-sh" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 文件名称</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">dbfilename</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> dump.rdb</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 文件保存路径</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">dir</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> /home/work/app/redis/data/</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 如果持久化出错，主进程是否停止写入</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">stop-writes-on-bgsave-error</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> yes</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 是否压缩</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">rdbcompression</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> yes</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 导入时是否检查</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">rdbchecksum</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> yes</span></span></code></pre></div><ul><li><p><strong>dbfilename：</strong> 配置文件名，可以通过执行 <code>config set dir {newDir}</code> 和 <code>config set dbfilename {newFileName}</code> 运行期动态执行，当下次运行时RDB文件会保存到新目录</p></li><li><p><strong>dir：</strong> 可以通过执行 <code>config set dir {newDir}</code> 和 <code>config set dbfilename {newFileName}</code> 运行期动态执行，当下次运行时RDB文件会保存到新目录</p></li><li><p><strong>压缩：</strong> Redis默认采用 <strong>LZF算法</strong> 对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 <code>config set rdbcompression {yes|no}</code> 动态修改。</p></li><li><p><strong>校验：</strong> 如果Redis加载损坏的RDB文件时拒绝启动，这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为 no</p></li></ul><h3 id="rdb-的优缺点" tabindex="-1"><a class="header-anchor" href="#rdb-的优缺点"><span>RDB 的优缺点</span></a></h3><ul><li><p><strong>优点：</strong></p><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题</li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了 <strong>AOF持久化</strong> 方式来解决</p></li></ul><h2 id="aof-持久化" tabindex="-1"><a class="header-anchor" href="#aof-持久化"><span>AOF 持久化</span></a></h2><blockquote><p>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。</p><p>AOF的主要作用是解决了数据持久化的实时性，目前已经是 <strong>Redis持久化的主流方式</strong></p></blockquote><p>而AOF日志采用写后日志，即 <strong>先写内存，后写日志</strong></p><p><img src="https://media.zenghr.cn/blog/img/20210802/a20AVK.jpeg" alt="a20AVK"></p><p>Redis要求高性能，采用写日志有两方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作</li></ul><h3 id="如何实现-aof" tabindex="-1"><a class="header-anchor" href="#如何实现-aof"><span>如何实现 AOF</span></a></h3><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）</p><ul><li><p><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 <strong>aof_buf</strong> 缓冲区。</p></li><li><p><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略</p></li></ul><p><img src="https://media.zenghr.cn/blog/img/20210802/LATaFC.jpeg" alt="LATaFC"></p><ul><li><strong>Always</strong> - 同步写回：每个写命令执行完，立马同步地将日志写回磁盘</li><li><strong><code>Everysec(推荐)</code></strong> - 每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</li><li><strong>No</strong> - 操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘(不推荐)</li></ul><h3 id="conf-配置aof" tabindex="-1"><a class="header-anchor" href="#conf-配置aof"><span>Conf 配置AOF</span></a></h3><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># appendonly参数开启AOF持久化</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">appendonly</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> no</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># AOF持久化的文件名，默认是appendonly.aof</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">appendfilename</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> &quot;appendonly.aof&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">dir</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> ./</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 同步策略</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># appendfsync always</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> everysec</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># appendfsync no</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># aof重写期间是否同步</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">no-appendfsync-on-rewrite</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> no</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 重写触发配置</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">auto-aof-rewrite-percentage</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 100</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">auto-aof-rewrite-min-size</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> 64mb</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 加载aof出错如何处理</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">aof-load-truncated</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> yes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 文件重写策略</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">aof-rewrite-incremental-fsync</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是Redis中关于AOF的主要配置信息：</p><ul><li><p><code>appendonly</code>：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p></li><li><p><code>appendfilename</code>：这个参数项很好理解了，就是AOF文件的名字</p></li><li><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置操作命令向AOF文件中同步的策略</p></li></ul><h2 id="rdb和aof混合方式" tabindex="-1"><a class="header-anchor" href="#rdb和aof混合方式"><span>RDB和AOF混合方式</span></a></h2><blockquote><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作</p></blockquote><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了</p><p><img src="https://media.zenghr.cn/blog/img/20210802/yBKz08.jpeg" alt="yBKz08"></p><p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><ul><li><p><a href="https://www.cnblogs.com/ybyn/p/14157568.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/ybyn/p/14157568.html</a></p></li><li><p><a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000015983518</a></p></li><li><p><a href="https://blog.csdn.net/qq_41434612/article/details/108791437" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_41434612/article/details/108791437</a></p></li><li><p><a href="https://www.cnblogs.com/liang24/p/14180036.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/liang24/p/14180036.html</a></p></li><li><p><a href="https://www.jianshu.com/p/d3ba7b8ad964" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/d3ba7b8ad964</a></p></li><li><p><a href="https://blog.csdn.net/liupeifeng3514/article/details/79048767" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/liupeifeng3514/article/details/79048767</a></p></li><li><p><a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html" target="_blank" rel="noopener noreferrer">https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html</a></p></li></ul>`,53)]))}const d=i(l,[["render",t]]),o=JSON.parse('{"path":"/database/redis/06.Redis%E8%BF%9B%E9%98%B6-%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%99%E7%A8%8B.html","title":"Redis进阶-持久化机制","lang":"zh-CN","frontmatter":{"title":"Redis进阶-持久化机制","date":"2021-08-02T20:00:00.000Z","re":"2021-08-02-redis-rdb-aof","description":"Redis 持久化机制 Redis是一个支持持久化的内存数据库，也就是说 redis 需要经常将内存中的数据同步到硬盘来保证持久化 Redis持久化主要分为两种方式，分别是RDB和AOF，当然实际场景下还会使用这两种的混合模式 前言 Redis的数据正常都是存储在内存内，如果宕机突然发生，数据就会全部丢失，因此需要提供一种方式保证 redis 的数据不...","permalink":"/passages/2021-08-02-redis-rdb-aof.html","head":[["meta",{"property":"og:url","content":"https://blog.zenghr.cn/passages/2021-08-02-redis-rdb-aof.html"}],["meta",{"property":"og:site_name","content":"Zenghr"}],["meta",{"property":"og:title","content":"Redis进阶-持久化机制"}],["meta",{"property":"og:description","content":"Redis 持久化机制 Redis是一个支持持久化的内存数据库，也就是说 redis 需要经常将内存中的数据同步到硬盘来保证持久化 Redis持久化主要分为两种方式，分别是RDB和AOF，当然实际场景下还会使用这两种的混合模式 前言 Redis的数据正常都是存储在内存内，如果宕机突然发生，数据就会全部丢失，因此需要提供一种方式保证 redis 的数据不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://media.zenghr.cn/blog/img/20210802/eFa8oF.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-07T17:56:45.000Z"}],["meta",{"property":"article:published_time","content":"2021-08-02T20:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-07T17:56:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis进阶-持久化机制\\",\\"image\\":[\\"https://media.zenghr.cn/blog/img/20210802/eFa8oF.png\\",\\"https://media.zenghr.cn/blog/img/20210802/a20AVK.jpeg\\",\\"https://media.zenghr.cn/blog/img/20210802/LATaFC.jpeg\\",\\"https://media.zenghr.cn/blog/img/20210802/yBKz08.jpeg\\"],\\"datePublished\\":\\"2021-08-02T20:00:00.000Z\\",\\"dateModified\\":\\"2025-04-07T17:56:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zenghr\\"}]}"]]},"git":{"createdTime":1744048605000,"updatedTime":1744048605000,"contributors":[{"name":"zenghr","username":"zenghr","email":"zenghr","commits":1,"url":"https://github.com/zenghr"}]},"readingTime":{"minutes":8.25,"words":2475},"filePathRelative":"database/redis/06.Redis进阶-持久化教程.md","localizedDate":"2021年8月2日","excerpt":"\\n<blockquote>\\n<p>Redis是一个支持持久化的内存数据库，也就是说 redis 需要经常将内存中的数据同步到硬盘来保证持久化</p>\\n<p>Redis持久化主要分为两种方式，分别是RDB和AOF，当然实际场景下还会使用这两种的混合模式</p>\\n</blockquote>\\n<h2>前言</h2>\\n<p>Redis的数据正常都是存储在内存内，如果宕机突然发生，数据就会全部丢失，因此需要提供一种方式保证 redis 的数据不会因为故障而丢失，这种机制就是 <strong>redis 的持久化机制</strong></p>\\n<p>目前 Redis 主流的持久化机制有两种：RDB 方式 和 AOF 方式</p>","autoDesc":true}');export{d as comp,o as data};
