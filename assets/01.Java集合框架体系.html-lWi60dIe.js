import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as e}from"./app-W8Rm2S8d.js";const l={};function n(p,i){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="java-集合框架体系" tabindex="-1"><a class="header-anchor" href="#java-集合框架体系"><span>Java 集合框架体系</span></a></h1><div class="hint-container tip"><p class="hint-container-title">提示</p><p>本文用于整合 集合框架的知识体系，如有不正确的地方请指出，感谢。</p><p><em>JDK Version：1.8.0.212</em></p></div><h2 id="数据结构概述" tabindex="-1"><a class="header-anchor" href="#数据结构概述"><span>数据结构概述</span></a></h2><p>数据结构就是数据在计算机中存储的方式，不同的数据结构，底层采用不同的存储算法，在执行具体的操作时，不同的算法会有不同的效率，有的查询效率慢，有的删除添加效率快等</p><h3 id="常见的数据结构" tabindex="-1"><a class="header-anchor" href="#常见的数据结构"><span>常见的数据结构</span></a></h3><ul><li><strong>数组(Array)</strong></li><li><strong>链表(Linked)</strong></li><li><strong>哈希表(Hash)</strong></li><li><strong>栈(Stack)</strong></li><li><strong>队列(Queue)</strong></li><li><strong>树(Tree)</strong></li><li><strong>图(Graph)</strong></li><li><strong>堆(Heap)</strong></li></ul><p>在日常的开发中，往往根据业务的需要，选择不同的数据结构，选择合适的集合类</p><p>这么多数据结构，我们又可以根据其数据结构特性(<code>是否连成一条线</code>)，分为 <strong>线性数据结构</strong> 和 <strong>非线性数据结构</strong></p><h3 id="线性数据结构" tabindex="-1"><a class="header-anchor" href="#线性数据结构"><span>线性数据结构</span></a></h3><h4 id="数组-array" tabindex="-1"><a class="header-anchor" href="#数组-array"><span>数组(Array)</span></a></h4><p>把具有相同类型的数据有序地组织在一起，称为数组。数组使用 <strong>索引/下标</strong> 来表示元素的存储位置。</p><p><strong>性能分析</strong></p><ul><li><p>添加操作：</p><p>如果是添加到数组尾部，只需要操作一次</p><p>如果添加到其他位置，则需要把后面的元素整体后移</p></li><li><p>删除操作：</p><p>如果是删除尾部元素，只需要操作一次</p><p>如果是删除其他位置元素，则需要把元素整体后移</p></li><li><p>修改操作：</p><p>给定索引，操作一次</p><p>根据内容，操作N次</p></li><li><p>查询操作：</p><p>给定索引，操作一次</p><p>根据内容，操作N次</p></li></ul><p>总结：基于数组(Array)的数据结构做查询修改是非常快的，添加和删除就比较慢</p><h4 id="链表-linked" tabindex="-1"><a class="header-anchor" href="#链表-linked"><span>链表(Linked)</span></a></h4><p>每个元素在内存中的位置不是有序的，而是通过在每个元素中记录下一个元素的位置链接在一起，称为链表。</p><p>链表又分为 单向链表 和 双向链表</p><ul><li>单向链表：元素中只记录了下一个元素的位置，所以只能单向遍历</li><li>双向链表：元素中记录了 上一个元素和下一个元素的位置，实现双向遍历</li></ul><p><img src="https://media.zenghr.cn/blog/img/20210426/LI9Wp8kMRf6s.png?imageslim" alt="mark"></p><p><img src="https://media.zenghr.cn/blog/img/20210426/q9bh5g5vWet3.png?imageslim" alt="mark"></p><p><strong>性能分析</strong></p><ul><li><p>添加操作：</p><p>添加位置在头部或尾部，操作一次</p><p>添加位置在其他位置，需要覆盖原有元素指向的位置，指向新的元素位置，新的元素则需要指向原有元素指向的位置</p></li><li><p>删除操作：</p><p>如果删除的元素是头部或尾部，操作一次</p><p>如果是中间元素，需要找到元素，删除操作一次</p></li><li><p>修改操作：</p><p>平均 (N + 1) / 2</p></li><li><p>查询操作：</p><p>平均 (N + 1) / 2</p></li></ul><p>总结：链表(Linked) 数据结构对于 添加删除操作较快，查询修改比较慢</p><h4 id="队列-queue" tabindex="-1"><a class="header-anchor" href="#队列-queue"><span>队列(Queue)</span></a></h4><p>队列是一种特殊的线性表，它只允许在头部进行删除操作，尾部进行添加操作，是一种受限制的线性表。</p><p>队列又分为 单向队列 和 双向队列:</p><ul><li>单向队列(Queue)：先进先出，只能在队尾插入，从队列头部删除</li><li>双向队列(Deque)：两端都可以进行添加删除数据，不能操作中间的数据</li></ul><p><img src="https://media.zenghr.cn/blog/img/20210426/lSzKkkebCV20.png?imageslim" alt="单向队列"></p><p><img src="https://media.zenghr.cn/blog/img/20210426/FtkpcnNHuvqe.png?imageslim" alt="双向队列"></p><p>总结：擅长操作头部和尾部</p><h4 id="栈-stack" tabindex="-1"><a class="header-anchor" href="#栈-stack"><span>栈(stack)</span></a></h4><p>栈（stack）又名堆栈，它是一种运算受限的线性表，后进先出(LIFO)。</p><img src="https://media.zenghr.cn/blog/img/20210426/AAjnrOjbiFIU.png?imageslim" alt="栈结构" style="zoom:33%;"><p>栈结构仅允许在表的一端进行插入和删除运算，这一端被称为 <strong>栈顶</strong>，相对地，把另一端称为 <strong>栈底</strong>。 向一个栈中插入新元素又称作 <strong>入栈</strong>，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素。从一 个栈中删除元素又称作 <strong>出栈</strong></p><h2 id="集合框架体系" tabindex="-1"><a class="header-anchor" href="#集合框架体系"><span>集合框架体系</span></a></h2><p>集合是Java中提供的一种容器，可以用来存储多个数据，根据不同的存储方式形成的体系结构，就叫做集合框架体系。</p><p><img src="https://media.zenghr.cn/blog/img/20210426/HGAR6bEbSSch.png?imageslim" alt="集合继承关系"></p><p>每一种容器类底层拥有不同的底层算法(数据结构)。</p><h2 id="iterable-接口" tabindex="-1"><a class="header-anchor" href="#iterable-接口"><span>Iterable 接口</span></a></h2><p>从上图可以看出 <strong>Iterable</strong> 接口是所有集合的超类， 实现此接口允许对象成为 for-each 循环的目标，它是 Java 中的一种 <code>语法糖</code></p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> list </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> ArrayList</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> obj</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> list){}</span></span></code></pre></div><p><strong>其他遍历方式</strong></p><p><strong>Iterable</strong> 接口有一个方法，就是</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Iterator</span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">T</span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> iterator</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>该方法能创建一个轻量级的迭代器，用于安全的遍历元素，移除元素，如果在for-each中删除集合中的元素，是不安全的，会抛出 <code>ConcurrentModificationException</code> 异常，所以尽量使用迭代器的方式进行遍历，删除元素</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Iterator</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> it </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> coll</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">iterator</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> it</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">hasNext</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">	System</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">it</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">next</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>集合容器主要包括 Collection 和 Map 两种，Collection 存储对象的集合，而 Map 存储 键值对 (key - value)</p></div><h2 id="collection-顶层接口" tabindex="-1"><a class="header-anchor" href="#collection-顶层接口"><span>Collection 顶层接口</span></a></h2><p>Collection 是顶层接口，它主要用于定义集合的约定</p><p>List 接口继承于 Collection 接口，同时也是 ArrayList、LinkedList 的父类</p><p>Set 接口跟 List 接口处于同级的层次，也继承于 Collection 接口，同时也是 HashSet、TreeSet 的父类</p><p>Map 是一个支持 key-value 存储的对象，Map 不能包含重复的 key，注意 Map 不继承于 Collection 接口</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>实现类命名方式：底层数据结构 + 实现的集合接口。<em>e.g：ArrayList (数组结构 + List 接口)</em></p></div><h2 id="list-接口" tabindex="-1"><a class="header-anchor" href="#list-接口"><span>List 接口</span></a></h2><p>List接口是 Collection接口 的子接口，List 接口定义了一种规范，要求该容器允许记录<strong>元素的添加顺</strong><strong>序，也允许元素重复</strong>。那么List接口的实现类都会遵循这一种规范</p><h3 id="常用实现类" tabindex="-1"><a class="header-anchor" href="#常用实现类"><span>常用实现类</span></a></h3><ul><li><strong>ArrayList：</strong> 表示数组结构，底层采用数组实现，开发中使用最多的类。</li><li><strong>LinkedList：</strong> 表示链表结构，表示单向链表和双向链表</li><li><strong>Stack：</strong> 栈结构，使用数组实现，使用不多</li><li><strong>Vector：</strong> 向量，老版的 ArrayList，使用数组实现，使用不多</li></ul><h3 id="常用-api" tabindex="-1"><a class="header-anchor" href="#常用-api"><span>常用 API</span></a></h3><p><strong>添加操作</strong></p><ul><li><em>boolean add(E e)：</em> 将元素添加到列表末尾</li><li><em>void add(int index, E element)：</em> 在列表的指定位置插入指定元素</li><li><em>boolean addAll(Collection&lt;? extends E&gt; c)：</em> 将指定 collection 中的所有元素都插入到列表中的指定位置</li></ul><p><strong>删除操作</strong></p><ul><li><em>boolean remove(Object o)：</em> 从此列表中移除第一次出现的指定元素</li><li><em>E remove(int index)：</em> 移除列表中指定位置的元素</li><li><em>boolean removeAll(Collection&lt;? extends E&gt; c)：</em> 从列表中移除指定 collection 中包含的其所有元素</li></ul><p><strong>修改操作</strong></p><ul><li><em>Object set(int index, Object ele)：</em> 修改列表中指定索引位置的元素，返回被替换的旧元素</li></ul><p><strong>查询操作</strong></p><ul><li><em>int size()：</em> 返回当前列表中元素个数</li><li><em>boolean isEmpty()：</em> 判断当前列表中元素个数是否为0</li><li><em>Object get(int index)：</em> 查询列表中指定索引位置对应的元素</li><li><em>Object[] toArray()：</em> 把列表对象转换为Object数组</li><li><em>boolean contains(Object o)：</em> 判断列表是否存在指定对象</li></ul><h2 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h2><p>ArrayList 是实现了 List 接口的 可扩容数组，它的内部是基于数组实现的，不是线程安全</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">transient</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">[] elementData</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><ul><li><p>其内部定义了一个 Object 类型的数组，所以它允许存储所有类型元素</p></li><li><p>ArrayList 内部有容量的概念，用于表示该数组能存储多大的数据</p></li><li><p>ArrayList 不是线程安全的容器，使用线程安全应该使用 <strong><code>Collections.synchronizedList</code></strong></p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> list </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> Collections</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">synchronizedList</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> ArrayList</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(...))</span></span></code></pre></div></li><li><p>在集合遍历中，删除添加改变集合的结构时，会出现异常</p></li></ul><h2 id="vector" tabindex="-1"><a class="header-anchor" href="#vector"><span>Vector</span></a></h2><p>Vector 同 ArrayList 一样，都是基于数组实现的，只不过 Vector 是线程安全的容器。内部每个方法使用 <strong><code>synchronized</code></strong> 进行同步，避免多线程引起的安全问题，但是也导致了 Vector 效率低下</p><h2 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h2><p>LinkedList 类，底层采用链表算法，实现了链表，队列，栈的数据结构。无论是链表还是队列主要 操作的都是头和尾的元素，因此在 LinkedList 类中除了 List 接口的方法，还有很多操作头尾的方法</p><blockquote><p>注：这个实现也不是线程安全的</p></blockquote><h3 id="常用-api-1" tabindex="-1"><a class="header-anchor" href="#常用-api-1"><span>常用 API</span></a></h3><p><strong>栈操作</strong></p><ul><li><em>void push(Object e)：</em> 将元素推入此列表所表示的栈。</li><li><em>Object pop()：</em> 从此列表所表示的栈处弹出一个元素</li><li><em>Object peek()：</em> 获取但不移除此列表的头（第一个元素）</li></ul><p><strong>单向队列</strong></p><ul><li><p><strong>会抛出异常👇</strong></p></li><li><p><em>boolean add(Object e)：</em> 入队操作</p></li><li><p><em>Object remove()：</em> 出队操作</p></li><li><p><em>Object element()：</em> 获取但不移除此列表的头（第一个元素）</p></li><li><p><strong>不会抛出异常👇</strong></p></li><li><p><em>boolean offer(Object e)：</em> 入队操作</p></li><li><p><em>Object poll()：</em> 出队操作</p></li><li><p><em>Object peek()：</em> 获取但不移除此列表的头（第一个元素）</p></li></ul><p><strong>双向队列</strong></p><ul><li><p><strong>会抛出异常👇</strong></p></li><li><p><em>boolean addFirst(Object e)：</em> 头部入队操作</p></li><li><p><em>boolean addLast(Object e)：</em> 尾部入队操作</p></li><li><p><em>Object removeFirst()：</em> 头部出队操作</p></li><li><p><em>Object removeLast()：</em> 尾部出队操作</p></li><li><p><em>Object getFirst()：</em> 返回此列表的第一个元素</p></li><li><p><em>Object getLast()：</em> 返回此列表的最后一个元素</p></li><li><p><strong>不会抛出异常👇</strong></p></li><li><p><em>boolean offerFirst(Object e)：</em> 头部入队操作</p></li><li><p><em>boolean offerLast(Object e)：</em> 尾部入队操作</p></li><li><p><em>Object pollFirst()：</em> 头部出队操作</p></li><li><p><em>Object pollLast()：</em> 尾部出队操作</p></li><li><p><em>Object peekFirst()：</em> 返回此列表的第一个元素</p></li><li><p><em>Object peekLast()：</em> 返回此列表的最后一个元素</p></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>LinkedList之所以有这么多方法，是因为自身实现了多种数据结构，而不同的数据结构的操作方法 名称不同</p></div><h2 id="stack" tabindex="-1"><a class="header-anchor" href="#stack"><span>Stack</span></a></h2><p>Stack 表示栈，是 Vector 类的子类，具有先进后出的特性，拥有push（入栈），pop（出栈）方法</p><h2 id="set-接口" tabindex="-1"><a class="header-anchor" href="#set-接口"><span>Set 接口</span></a></h2><p>Set 是 Collection 子接口，Set 接口定义了一种规范，也就是该容器<strong>不记录元素的添加顺序，也不允</strong><strong>许元素重复</strong>，那么 Set 接口的实现类都遵循这一种规范。</p><h3 id="常用实现类-1" tabindex="-1"><a class="header-anchor" href="#常用实现类-1"><span>常用实现类</span></a></h3><ul><li><strong>HashSet：</strong> 底层采用哈希表实现，开发中使用较多的实现类</li><li><strong>TreeSet：</strong> 底层采用红黑树实现，可以对集合中元素排序，默认自然排序</li></ul><h3 id="常用-api-2" tabindex="-1"><a class="header-anchor" href="#常用-api-2"><span>常用 API</span></a></h3><ul><li><em>boolean add(Object e)</em></li><li><em>boolean remove(Object e)</em></li><li><em>boolean contains(Object e)</em></li><li><em>void clear()</em></li><li><em>int size()</em></li></ul><h2 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset"><span>HashSet</span></a></h2><p>HashSet 是 Set 接口的实现类，底层采用哈希表实现，不能保证元素的有序，保证了元素的唯一，运行存储 NULL 元素，注意 它不是线程安全的容器。</p><p>查看源码可知，其内部是 HashMap 的实例</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> transient</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">E</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> map</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> HashSet</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">    map </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre></div><h3 id="底层工作原理" tabindex="-1"><a class="header-anchor" href="#底层工作原理"><span>底层工作原理</span></a></h3><p>内部使用哈希表实现，每个元素需要先计算 <strong>哈希值</strong>，再通过 <strong>散列函数</strong> 计算出元素的位置</p><p>如果该位置存在元素，则去除该位置上 <strong>链表</strong> 的所有元素，通过 <strong>equals</strong> 方法依次比较，如果有重复的元素，则不添加，没有重复的元素，则在其 <strong>链表</strong> 后面添加，如下图👇</p><p><img src="https://media.zenghr.cn/blog/img/20210426/LRMSB3ygqTSg.png?imageslim" alt="mark"></p><h3 id="hashcode-和-equals" tabindex="-1"><a class="header-anchor" href="#hashcode-和-equals"><span>hashCode 和 equals</span></a></h3><p>根据其工作原理，我们可以得知，在哈希表中元素的 hashCode 和 equals 方法很重要</p><p>每一个存储到好像表中的对象，都得覆盖hashCode和equals方法用来判断是否是同一个对象，一 般的，根据对象的字段数据比较来判断，通常情况下equals为true的时候hashCode也应该相等</p><h2 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset"><span>TreeSet</span></a></h2><p>TreeSet 是 Set 接口的实现类，底层采用红黑树算法实现，会对存储的元素进行排序，默认是自然排序(从小到大)</p><p>注意：TreeSet 不允许存储 NULL 值</p><p><img src="https://media.zenghr.cn/blog/img/20210426/MnWGajJtO982.png?imageslim" alt="mark"></p><ul><li>红黑树存储的时候是左边的存较小的元素，右边存储较大的元素</li><li>由于 TreeSet 是平衡二叉树，如果树不平衡，会对节点进行调整</li></ul><p>当我们使用 TreeSet 存储元素时，此时要求元素必须具备 <strong>比较大小</strong> 的能力，也就是实现 <em>java.util.Comparable</em> 接口</p><h3 id="comparable-接口" tabindex="-1"><a class="header-anchor" href="#comparable-接口"><span>Comparable 接口</span></a></h3><p>TreeSet 会调用元素的 <code>compareTo</code> 方法来比较元素的大小关系,然后将集合元素按照升序排列</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> Comparable</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> compareTo</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#E06C75;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> o</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>比较规则，拿当前元素和另一个元素比较：</p><ul><li>返回负数，当前元素小</li><li>返回正数，当前元素大</li><li>等于 0，一样，此时认为两个为同一个对象</li></ul><p>如果我们存储进 TreeSet 集合中的元素没有 比较功能，可以让该元素实现 Comparable 接口，并 覆盖compareTo方法，在该方法编写比较规则，否则添加会报错。</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> ComparableExample</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> java.lang.</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Comparable</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">User</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> compareTo</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">ComparableExample</span><span style="--shiki-light:#E06C75;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> o</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ... 比较规则</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><h3 id="comparator-接口" tabindex="-1"><a class="header-anchor" href="#comparator-接口"><span>Comparator 接口</span></a></h3><p>当原有的排序规则不满足我们的需求时，我们可以提供一个 <strong>外部比较器(Comparator)</strong> 通过 TreeSet 构造器传入该比较器的实现类</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> Comparator</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> compare</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#E06C75;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> o1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#E06C75;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> o2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>使用方法：</p><p>因为 Comparator 实现类只是用一次，我们可以使用匿名内部类，JDK8 提供了 lambda 表达式，我们可以简写</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 需求：通过比较字符串长度</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 原有的 String 自带的比较规则不满足需求，使用 Comparator</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">    TreeSet</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> treeSet </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> TreeSet</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">Comparator</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">comparingInt</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(String</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">::</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">length)</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">    treeSet</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;abc&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">    treeSet</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;apple&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">    treeSet</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;zeng&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(treeSet);</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre></div><h2 id="map-接口" tabindex="-1"><a class="header-anchor" href="#map-接口"><span>Map 接口</span></a></h2><p>Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value</p><p>Map 结构如下👇</p><img src="https://media.zenghr.cn/blog/img/20210426/GkR0fNhc2UKS.png?imageslim" alt="mark" style="zoom:33%;"><p>其实能看出一个 Map 其实就由多个 key-value（键值对）组成的，每一个键值对我们使用Entry表示，键（key值）不可重复，value值可以重复</p><p>所以也可以说 Map 的 key 是存储在 set 集合中，不可重复</p><h3 id="常用实现类-2" tabindex="-1"><a class="header-anchor" href="#常用实现类-2"><span>常用实现类</span></a></h3><ul><li><strong>HashMap：</strong> 底层基于哈希表算法</li><li><strong>TreeMap：</strong> 底层基于红黑树算法</li></ul><h3 id="常用-api-3" tabindex="-1"><a class="header-anchor" href="#常用-api-3"><span>常用 API</span></a></h3><ul><li><strong>boolean put(Object key, Object value)： 存储一个键值对到Map中</strong></li><li>boolean putAll(Map m)： 把 m 中的所有键值对添加到当前Map中</li><li><strong>Object remove(Object key)： 从Map中删除指定key的键值对，并返回被删除key对应的value</strong></li><li>boolean isEmpty()： 判断当前Map中键值对个数是否为0</li><li><strong>Object get(Object key)： 返回Map中指定key对应的value值，如果不存在该key，返回null</strong></li><li>boolean containsKey(Object key)： 判断Map中是否包含指定 key</li><li>boolean containsValue(Object value)： 判断Map中是否包含指定 value</li><li><strong>Set keySet()： 返回Map中所有 key 所组成的Set集合</strong></li><li>Collection values()： 返回Map中所有 value 所组成的Set集合</li><li>Set entrySet()： 返回Map中所有键值对所组成的Set集合</li></ul><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h2><p>HashMap 底层基于哈希表算法，Map中存储的 key 对象的 hashCode 值决定了在哈希表中的存储位 置，因为Map中的 key 是 Set，所以不能保证添加的先后顺序，也不允许重复</p><p>因为 HashSet 内部使用的就是 HashMap 所以两两者原理一致，HashSet 只是在 HashMap 上封装了一层，其底层工作原理一致</p><h2 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap"><span>TreeMap</span></a></h2><p>TreeMap底层基于红黑树算法，因为Map中的 key 是 Set，所以不能保证添加的先后顺序，也不允 许重复，但是Map中存储的 key 会默认使用自然排序（从小到大），和 TreeSet 一样，除了可以使用自然 排序也可以自定义排序</p><p>底层工作原理和 TreeSet 一致</p><h2 id="集合框架-工具类" tabindex="-1"><a class="header-anchor" href="#集合框架-工具类"><span>集合框架 工具类</span></a></h2><h3 id="arrays" tabindex="-1"><a class="header-anchor" href="#arrays"><span>Arrays</span></a></h3><p>Arrays类是数组的工具类，其中包含对数组的拷贝、格式化、排序查询等方法</p><ul><li><strong>Arrays.copyOf(T[] original, int newLength)：</strong> 数组拷贝</li><li>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：System类下的数组拷贝方法</li><li><em><strong>Arrays.toString()：</strong></em> 数组格式化输出</li><li><strong>Arrays.sort()：</strong> 数组排序，内部使用快速排序</li><li><strong>Arrays.binarySearch：</strong> 二分查找</li><li><strong>asList()：</strong> 将数组转化为 List 集合，但是<strong>不可改变长度</strong></li></ul><h3 id="collections" tabindex="-1"><a class="header-anchor" href="#collections"><span>Collections</span></a></h3><p>Collections 是一个操作 Collection（Set、 List ）和 Map 等集合的工具类</p><p><strong>常用 API</strong></p><p><em>排序操作</em></p><ul><li>reverse(List)： 反转 List 中元素的顺序</li><li>shuffle(List)： 对 List 集合元素进行随机排序</li><li><strong>sort(List)： 根据元素的自然顺序对指定 List 集合元素按升序排序</strong></li><li>sort(List， Comparator)： 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap(List， int， int)： 将指定 list 集合中的 i 处元素和 j 处元素进行交换</li></ul><p><em>查找和替换</em></p><ul><li>Object max(Collection)： 根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection， Comparator)： 根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)</li><li>Object min(Collection， Comparator)</li><li>int frequency(Collection， Object)： 返回指定集合中指定元素的出现次数</li><li><strong>void copy(List dest,List src)：将src中的内容复制到dest中</strong></li><li>boolean replaceAll(List list， Object oldVal， Object newVal)： 使用新值替换List 对象的所有旧值</li></ul><p><strong>解决多线程并发访问集合时的线程安全问题</strong></p><p>Collections提供了基本每种集合类型都有的方法: <strong><code>synchronizedXxx()</code></strong> 方法,以解决多个线程同时操作一个集合的并发问题</p><div class="language-java" data-highlighter="shiki" data-ext="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//通过如下的方法保证List的线程安全性</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> list </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;"> Collections</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">synchronizedList</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(list1);</span></span></code></pre></div>`,151)]))}const k=s(l,[["render",n]]),o=JSON.parse('{"path":"/Java/collection/01.Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB.html","title":"Java 集合框架体系","lang":"zh-CN","frontmatter":{"title":"Java 集合框架体系","date":"2021-04-25T20:00:00.000Z","re":"2021-04-25-java-collection-frame","category":["Java"],"description":"Java 集合框架体系 提示 本文用于整合 集合框架的知识体系，如有不正确的地方请指出，感谢。 JDK Version：1.8.0.212 数据结构概述 数据结构就是数据在计算机中存储的方式，不同的数据结构，底层采用不同的存储算法，在执行具体的操作时，不同的算法会有不同的效率，有的查询效率慢，有的删除添加效率快等 常见的数据结构 数组(Array) 链...","permalink":"/passages/2021-04-25-java-collection-frame.html","head":[["meta",{"property":"og:url","content":"https://blog.zenghr.cn/passages/2021-04-25-java-collection-frame.html"}],["meta",{"property":"og:site_name","content":"Zenghr"}],["meta",{"property":"og:title","content":"Java 集合框架体系"}],["meta",{"property":"og:description","content":"Java 集合框架体系 提示 本文用于整合 集合框架的知识体系，如有不正确的地方请指出，感谢。 JDK Version：1.8.0.212 数据结构概述 数据结构就是数据在计算机中存储的方式，不同的数据结构，底层采用不同的存储算法，在执行具体的操作时，不同的算法会有不同的效率，有的查询效率慢，有的删除添加效率快等 常见的数据结构 数组(Array) 链..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://media.zenghr.cn/blog/img/20210426/LI9Wp8kMRf6s.png?imageslim"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-07T14:30:15.000Z"}],["meta",{"property":"article:published_time","content":"2021-04-25T20:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-07T14:30:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 集合框架体系\\",\\"image\\":[\\"https://media.zenghr.cn/blog/img/20210426/LI9Wp8kMRf6s.png?imageslim\\",\\"https://media.zenghr.cn/blog/img/20210426/q9bh5g5vWet3.png?imageslim\\",\\"https://media.zenghr.cn/blog/img/20210426/lSzKkkebCV20.png?imageslim\\",\\"https://media.zenghr.cn/blog/img/20210426/FtkpcnNHuvqe.png?imageslim\\",\\"https://media.zenghr.cn/blog/img/20210426/HGAR6bEbSSch.png?imageslim\\",\\"https://media.zenghr.cn/blog/img/20210426/LRMSB3ygqTSg.png?imageslim\\",\\"https://media.zenghr.cn/blog/img/20210426/MnWGajJtO982.png?imageslim\\"],\\"datePublished\\":\\"2021-04-25T20:00:00.000Z\\",\\"dateModified\\":\\"2025-04-07T14:30:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zenghr\\"}]}"]]},"git":{"createdTime":1744036215000,"updatedTime":1744036215000,"contributors":[{"name":"zenghr","username":"zenghr","email":"zenghr","commits":1,"url":"https://github.com/zenghr"}]},"readingTime":{"minutes":14.34,"words":4303},"filePathRelative":"Java/collection/01.Java集合框架体系.md","localizedDate":"2021年4月25日","excerpt":"\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>本文用于整合 集合框架的知识体系，如有不正确的地方请指出，感谢。</p>\\n<p><em>JDK Version：1.8.0.212</em></p>\\n</div>\\n<h2>数据结构概述</h2>\\n<p>数据结构就是数据在计算机中存储的方式，不同的数据结构，底层采用不同的存储算法，在执行具体的操作时，不同的算法会有不同的效率，有的查询效率慢，有的删除添加效率快等</p>\\n<h3>常见的数据结构</h3>\\n<ul>\\n<li><strong>数组(Array)</strong></li>\\n<li><strong>链表(Linked)</strong></li>\\n<li><strong>哈希表(Hash)</strong></li>\\n<li><strong>栈(Stack)</strong></li>\\n<li><strong>队列(Queue)</strong></li>\\n<li><strong>树(Tree)</strong></li>\\n<li><strong>图(Graph)</strong></li>\\n<li><strong>堆(Heap)</strong></li>\\n</ul>","autoDesc":true}');export{k as comp,o as data};
